#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
Usage: audit-context [--session [<path>]] [--flagged] [--top <N>] [--json] [--help]

Static inventory of context-contributing sources and session token analysis.

Scans:
  ~/.claude/skills/*/SKILL.md        Size and word count
  ~/.claude/skills/*/rules/*.md      Always-on files (count)
  ~/.claude/skills/*/references/*.md On-demand files (count)
  ~/CLAUDE.md and project CLAUDE.md  Size and word count (recursive)
  ~/.claude/projects/*/memory/*.md   Auto-memory files
  ~/.claude/settings.json            Plugins, MCP servers, and tool counts

Session analysis (--session):
  Parses JSONL to extract per-turn token usage, context growth,
  top spikes, and cache hit rates.

Options:
  --session [<path>]  Include session token analysis. Auto-detects
                      most recent JSONL if no path given.
  --flagged           Only show items with flags (LARGE, RULES, MCP)
  --top <N>           Show only the top N entries by size
  --json              Output as JSON
  --help              Show this help message

Exit codes:
  0  Success
  1  ~/.claude/skills/ not found
EOF
}

JSON_OUTPUT=false
DO_SESSION=false
SESSION_PATH=""
FLAGGED_ONLY=false
TOP_N=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --json) JSON_OUTPUT=true; shift ;;
    --flagged) FLAGGED_ONLY=true; shift ;;
    --top) TOP_N="$2"; shift 2 ;;
    --session)
      DO_SESSION=true
      shift
      # Next arg is optional path (not another flag)
      if [[ $# -gt 0 && "$1" != --* ]]; then
        SESSION_PATH="$1"; shift
      fi
      ;;
    --help) usage; exit 0 ;;
    *) echo "Unknown option: $1" >&2; usage >&2; exit 1 ;;
  esac
done

SKILLS_DIR="$HOME/.claude/skills"

if [[ ! -d "$SKILLS_DIR" ]]; then
  echo "~/.claude/skills/ not found" >&2
  exit 1
fi

# Helper: get file size in bytes (portable)
file_size() {
  wc -c < "$1" | tr -d ' '
}

# Helper: get word count
word_count() {
  wc -w < "$1" | tr -d ' '
}

# Helper: format bytes for display
format_size() {
  local bytes=$1
  if [[ $bytes -ge 1024 ]]; then
    echo "$(( (bytes + 512) / 1024 ))KB"
  else
    echo "${bytes}B"
  fi
}

# ── Static Inventory ─────────────────────────────────────────────

# Collect entries as tab-separated: source \t size_bytes \t words \t loads \t flag
entries=()

# Scan SKILL.md files
for skill_dir in "$SKILLS_DIR"/*/; do
  [[ -d "$skill_dir" ]] || continue
  skill_name=$(basename "$skill_dir")

  skill_file="$skill_dir/SKILL.md"
  if [[ -f "$skill_file" ]]; then
    s=$(file_size "$skill_file")
    w=$(word_count "$skill_file")
    flag="-"
    [[ $w -gt 500 ]] && flag="LARGE"
    entries+=("skills/$skill_name/SKILL.md	$s	$w	on-trigger	$flag")
  fi

  rules_dir="$skill_dir/rules"
  if [[ -d "$rules_dir" ]]; then
    for rule_file in "$rules_dir"/*.md; do
      [[ -f "$rule_file" ]] || continue
      rule_name=$(basename "$rule_file")
      s=$(file_size "$rule_file")
      w=$(word_count "$rule_file")
      entries+=("skills/$skill_name/rules/$rule_name	$s	$w	always-on	RULES")
    done
  fi

  refs_dir="$skill_dir/references"
  if [[ -d "$refs_dir" ]]; then
    for ref_file in "$refs_dir"/*.md; do
      [[ -f "$ref_file" ]] || continue
      ref_name=$(basename "$ref_file")
      s=$(file_size "$ref_file")
      w=$(word_count "$ref_file")
      entries+=("skills/$skill_name/references/$ref_name	$s	$w	on-demand	-")
    done
  fi
done

# CLAUDE.md files — global
if [[ -f "$HOME/CLAUDE.md" ]]; then
  s=$(file_size "$HOME/CLAUDE.md")
  w=$(word_count "$HOME/CLAUDE.md")
  flag="-"
  [[ $s -gt 2048 ]] && flag="LARGE"
  entries+=("CLAUDE.md (global)	$s	$w	always-on	$flag")
fi

# CLAUDE.md files — project root and subdirectories
# Discover all CLAUDE.md files under cwd (depth 3 max) excluding home dir
if [[ "$(pwd)" != "$HOME" ]]; then
  while IFS= read -r claude_file; do
    [[ -z "$claude_file" ]] && continue
    rel_path="${claude_file#$(pwd)/}"
    s=$(file_size "$claude_file")
    w=$(word_count "$claude_file")
    flag="-"
    [[ $s -gt 2048 ]] && flag="LARGE"
    if [[ "$rel_path" == "CLAUDE.md" ]]; then
      entries+=("CLAUDE.md (project)	$s	$w	always-on	$flag")
    else
      entries+=("$rel_path	$s	$w	always-on	$flag")
    fi
  done < <(find "$(pwd)" -maxdepth 3 -name "CLAUDE.md" -type f 2>/dev/null)
fi

# Auto-memory files
for mem_dir in "$HOME"/.claude/projects/*/memory/; do
  [[ -d "$mem_dir" ]] || continue
  project_hash=$(basename "$(dirname "$mem_dir")")
  for mem_file in "$mem_dir"*.md; do
    [[ -f "$mem_file" ]] || continue
    mem_name=$(basename "$mem_file")
    s=$(file_size "$mem_file")
    w=$(word_count "$mem_file")
    flag="-"
    [[ $w -gt 300 ]] && flag="LARGE"
    # Shorten project hash for display
    short_hash="${project_hash:0:20}"
    entries+=("memory/${short_hash}…/$mem_name	$s	$w	always-on	$flag")
  done
done

# Settings: plugins and MCP servers
SETTINGS_FILE="$HOME/.claude/settings.json"
plugin_count=0
mcp_count=0
plugin_names=()
if [[ -f "$SETTINGS_FILE" ]]; then
  # Count enabled plugins from enabledPlugins object
  if command -v jq &>/dev/null; then
    plugin_count=$(jq '[.enabledPlugins // {} | to_entries[] | select(.value == true)] | length' "$SETTINGS_FILE" 2>/dev/null || echo 0)
    while IFS= read -r pname; do
      [[ -n "$pname" ]] && plugin_names+=("$pname")
    done < <(jq -r '.enabledPlugins // {} | to_entries[] | select(.value == true) | .key | split("@")[0]' "$SETTINGS_FILE" 2>/dev/null)
    mcp_count=$(jq '.mcpServers // {} | keys | length' "$SETTINGS_FILE" 2>/dev/null || echo 0)
  else
    plugin_count=$(grep -c '@' "$SETTINGS_FILE" 2>/dev/null || true)
    plugin_count=${plugin_count:-0}
    mcp_count=$(sed -n '/"mcpServers"/,/^  }/p' "$SETTINGS_FILE" 2>/dev/null | grep -c '"[^"]*":' || true)
    mcp_count=${mcp_count:-0}
  fi
  flag="-"
  [[ $mcp_count -ge 5 ]] && flag="MCP"
  entries+=("settings.json (${plugin_count} plugins, ${mcp_count} MCP)	0	0	always-on	$flag")

  # Add per-plugin entries with estimated tool counts
  # Known tool counts for common plugins (tool descriptions always loaded)
  for pname in "${plugin_names[@]}"; do
    tool_est=2  # default estimate
    case "$pname" in
      playwright) tool_est=22 ;;
      context7) tool_est=2 ;;
      hookify) tool_est=5 ;;
      commit-commands) tool_est=4 ;;
      claude-code-setup) tool_est=2 ;;
      claude-md-management) tool_est=2 ;;
    esac
    pflag="-"
    [[ $tool_est -ge 10 ]] && pflag="HEAVY"
    entries+=("plugin: $pname (~${tool_est} tools)	0	$((tool_est * 50))	always-on	$pflag")
  done
fi

# Sort entries by size descending
IFS=$'\n' sorted=($(for e in "${entries[@]}"; do echo "$e"; done | sort -t$'\t' -k2 -rn))
unset IFS

# Compute totals
total_always_on_words=0
total_trigger_words=0
trigger_count=0

for entry in "${sorted[@]}"; do
  IFS=$'\t' read -r source size words loads flag <<< "$entry"
  case "$loads" in
    always-on)
      total_always_on_words=$((total_always_on_words + words))
      ;;
    on-trigger)
      total_trigger_words=$((total_trigger_words + words))
      trigger_count=$((trigger_count + 1))
      ;;
  esac
done

avg_trigger_words=0
[[ $trigger_count -gt 0 ]] && avg_trigger_words=$((total_trigger_words / trigger_count))

total_always_on_words=$((total_always_on_words + mcp_count * 200 + plugin_count * 50))

# Apply filters to create display list
display=()
count=0
for entry in "${sorted[@]}"; do
  IFS=$'\t' read -r source size words loads flag <<< "$entry"

  if [[ "$FLAGGED_ONLY" == true && "$flag" == "-" ]]; then
    continue
  fi

  display+=("$entry")
  count=$((count + 1))

  if [[ $TOP_N -gt 0 && $count -ge $TOP_N ]]; then
    break
  fi
done

filtered_count=${#display[@]}
total_count=${#sorted[@]}

# ── Session Token Analysis ───────────────────────────────────────

session_turns=0
session_start=0
session_current=0
session_growth_rate=0
session_cache_hit_pct=0
# Arrays for top spikes: "turn delta total" lines, sorted by delta desc
session_spikes=()

if [[ "$DO_SESSION" == true ]]; then
  # Auto-detect session JSONL if not provided
  if [[ -z "$SESSION_PATH" ]]; then
    SESSION_PATH=$(ls -t "$HOME"/.claude/projects/*/*.jsonl 2>/dev/null | head -1 || true)
  fi

  if [[ -n "$SESSION_PATH" && -f "$SESSION_PATH" ]]; then
    # Extract unique turn totals: total input cache_create cache_read
    turn_data=$(grep -o '"usage":{[^}]*}' "$SESSION_PATH" 2>/dev/null | awk -F'[,:]' '{
      input=0; cache_create=0; cache_read=0
      for(i=1;i<=NF;i++) {
        if($i ~ /^"input_tokens"$/) { gsub(/[^0-9]/,"",$( i+1)); input=$(i+1) }
        if($i ~ /^"cache_creation_input_tokens"$/) { gsub(/[^0-9]/,"",$( i+1)); cache_create=$(i+1) }
        if($i ~ /^"cache_read_input_tokens"$/) { gsub(/[^0-9]/,"",$( i+1)); cache_read=$(i+1) }
      }
      total = input + cache_create + cache_read
      print total, input, cache_create, cache_read
    }' | uniq)

    if [[ -n "$turn_data" ]]; then
      session_turns=$(echo "$turn_data" | wc -l | tr -d ' ')

      session_start=$(echo "$turn_data" | head -1 | awk '{print $1}')
      session_current=$(echo "$turn_data" | tail -1 | awk '{print $1}')

      if [[ $session_turns -gt 1 ]]; then
        session_growth_rate=$(( (session_current - session_start) / (session_turns - 1) ))
      fi

      # Cache hit rate: sum(cache_read) / sum(total) across all turns
      read -r total_sum cache_read_sum <<< "$(echo "$turn_data" | awk '{t+=$1; cr+=$4} END{print t, cr}')"
      if [[ $total_sum -gt 0 ]]; then
        session_cache_hit_pct=$(( cache_read_sum * 100 / total_sum ))
      fi

      # Top 5 spikes by absolute delta
      session_spikes_raw=$(echo "$turn_data" | awk '{
        n++; delta=$1-prev
        if(n>1) print (delta<0?-delta:delta), delta, n, $1
        prev=$1
      }' | sort -rn | head -5)

      while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        session_spikes+=("$line")
      done <<< "$session_spikes_raw"
    fi
  else
    echo "Warning: no session JSONL found" >&2
  fi
fi

# ── Output ───────────────────────────────────────────────────────

if [[ "$JSON_OUTPUT" == true ]]; then
  echo "{"
  echo '  "inventory": ['
  first=true
  for entry in "${display[@]}"; do
    IFS=$'\t' read -r source size words loads flag <<< "$entry"
    [[ "$first" == true ]] && first=false || echo ","
    printf '    {"source": "%s", "size_bytes": %s, "words": %s, "loads": "%s", "flag": "%s"}' \
      "$source" "$size" "$words" "$loads" "$flag"
  done
  echo ""
  echo "  ],"
  printf '  "showing": %d, "total_entries": %d,' "$filtered_count" "$total_count"
  echo ""
  printf '  "totals": {"always_on_words": %d, "avg_trigger_words": %d, "skills": %d, "plugins": %d, "mcp_servers": %d}' \
    "$total_always_on_words" "$avg_trigger_words" "$trigger_count" "$plugin_count" "$mcp_count"

  if [[ "$DO_SESSION" == true && $session_turns -gt 0 ]]; then
    echo ","
    printf '  "session": {"turns": %d, "start_tokens": %d, "current_tokens": %d, "growth_per_turn": %d, "cache_hit_pct": %d, "spikes": [' \
      "$session_turns" "$session_start" "$session_current" "$session_growth_rate" "$session_cache_hit_pct"
    first=true
    for spike in "${session_spikes[@]}"; do
      read -r abs_delta delta turn total <<< "$spike"
      [[ "$first" == true ]] && first=false || printf ","
      printf '{"turn": %d, "delta": %d, "total": %d}' "$turn" "$delta" "$total"
    done
    echo "]}"
  fi
  echo ""
  echo "}"
else
  # Markdown table
  if [[ $filtered_count -lt $total_count ]]; then
    echo "Showing $filtered_count of $total_count entries"
    echo ""
  fi

  printf "| %-50s | %7s | %5s | %-10s | %5s |\n" "Source" "Size" "Words" "Loads" "Flag"
  printf "|%-52s|%9s|%7s|%-12s|%7s|\n" "$(printf '%0.s-' {1..52})" "$(printf '%0.s-' {1..9})" "$(printf '%0.s-' {1..7})" "$(printf '%0.s-' {1..12})" "$(printf '%0.s-' {1..7})"

  for entry in "${display[@]}"; do
    IFS=$'\t' read -r source size words loads flag <<< "$entry"
    printf "| %-50s | %7s | %5s | %-10s | %5s |\n" "$source" "$(format_size "$size")" "$words" "$loads" "$flag"
  done

  echo ""
  echo "Totals:"
  echo "  Always-on context: ~${total_always_on_words} words (includes MCP/plugin overhead estimate)"
  echo "  Avg on-trigger cost: ~${avg_trigger_words} words per skill invocation"
  echo "  Skills: $trigger_count | Plugins: $plugin_count | MCP servers: $mcp_count"

  if [[ "$DO_SESSION" == true && $session_turns -gt 0 ]]; then
    echo ""
    echo "Session Analysis:"
    echo "  Turns: $session_turns"
    echo "  Starting context: ${session_start} tokens"
    echo "  Current context: ${session_current} tokens"
    echo "  Growth rate: ~${session_growth_rate} tokens/turn"
    echo "  Cache hit rate: ${session_cache_hit_pct}%"
    echo ""
    echo "Top Context Spikes:"
    i=0
    for spike in "${session_spikes[@]}"; do
      read -r abs_delta delta turn total <<< "$spike"
      i=$((i + 1))
      sign="+"
      [[ $delta -lt 0 ]] && sign=""
      echo "  ${i}. Turn $turn: ${sign}${delta} tokens (total: ${total})"
    done
  fi
fi
